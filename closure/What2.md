# 阮一峰关于 Javascript 中闭包的解读是否正确？

感觉讲的挺好的，考虑到之前被朴灵喷的很惨，所以开始怀疑博文中的讲解是否正确。

博文部分观点：

1. 我的理解是，闭包就是能够读取其他函数内部变量的函数。

2.由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

3.闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。


## First

关于闭包的概念，其实就是来自函数式语言。

```
var a = function () {
  var test = {};
  setTimeout(function () {
    console.log(test);
  }, 1000);
}
```

上面的例子中，test在a中定义，但在setTimeout的参数（函数）中对它保持了引用。当a被执行了，尽管a已经执行完（已经执行完），理论上来说a这个函数执行过程中产生的变量、对象都可以被销毁。但test由于被引用，所以不能随这个函数执行结束而被销毁，直到定时器里的函数被执行掉。

另外再来个例子：

```
var obj = function () {
  var a = '';
  return {
    set: function (val) {
      a = val;
    },
    get: function () {
      return a;
    }
  }
};

var b = obj();
b.set('new val');
b.get();


```

以上 obj这个函数在执行完之后理论上 函数体内东西都应该被回收掉。但它执行后的返回值 b 具有set和get方法。这两个方法里对a保持了引用，所以obj执行过程中产生的a就不会销毁。直到b先被回收，这个a才会回收。


引用维基百科：闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。


## Second

某些說法的確不嚴謹，但也沒必要噴。
比如：

> 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！

不使用 var 等於沒有聲明變量，而是相當於訪問了 window 的屬性。
和在 window 下聲明變量的區別在於，訪問 window 的屬性創建的變量可以 delete，在全局作用域下直接聲明的變量不可以 delete。


```
window.b = "hi";

b; // "hi"

delete b; // true

b; // ReferenceError: b is not defined

(function(){c = "hi"}());

c; // "hi"

delete c; // true

c; // ReferenceError: c is not defined

var a = "hi";

a; // "hi"

delete a; // false

a; // "hi"



```

回到正題，阮一峰關於閉包的說法也同樣不嚴謹：

> 闭包就是能够读取其他函数内部变量的函数。

其它函數，任意其它函數嗎？
我們看wikipedia這樣說：

> 閉包是由函式和與其相關的參照環境組合而成的實體。

簡單明瞭，既指明了閉包的組成部分，又限定了範圍，比「其它函數」不知高到哪裏去了。

況且，閉包只需有擴充變量的作用範圍即可，而無需有其它函數存在。

> 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。

混淆了閉包和函數內部定義的函數聲明、函數表達式。

即便在函數內部定義了函數，如果沒有引用父函數作用域的變量，也照樣可以不是閉包。

函數和環境，缺一不可，這纔是閉包。

























